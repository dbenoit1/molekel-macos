/*  MOLEKEL, Version 4.3, Date: 11.Nov.02
 *  Copyright (C) 2000-2002 Stefan Portmann (CSCS/ETHZ)
 *  (original IRIX GL implementation, concept and data structure
 *   by Peter F. Fluekiger, CSCS/UNI Geneva)
 *
 *  This software makes use of the 
 *  GLUT http://reality.sgi.com/mjk/glut3/glut3.html
 *  GLUI http://www.cs.unc.edu/~rademach/glui/
 *  libtiff http://www.libtiff.org/tiff-v3.5.5.tar.gz
 *  libjpeg ftp://ftp.uu.net/graphics/jpeg
 *  and in some versions of the 
 *  Mesa http://www.mesa3d.org/
 *  and the 
 *  libimage https://toolbox.sgi.com/toolbox/src/haeberli/libimage/index.html#dl
 *  libraries.
 *  An adapted version of the tr library by Brian Paul
 *  (http://www.mesa3d.org/brianp/TR.html)
 *  is part of the distribution.
 *
 *  The binary code is available free of charge but is not in the
 *  public domain. See license for details on conditions and restrictions.
 *  Source code is only available in the framework of a collaboration. 
 *
 *  Info: http://www.cscs.ch/molekel/
**/


#include <GLUT/glut.h>
/*#include <GLUI/glui.h>*/
#include <GL/glui.h>

#include "main.h"
#include "molekel.h"
#include "constant.h"
#include "general.h"
#include "output.h"
#include "maininterf.h"
#include "box.h"
#include "trackball.h"

static void matmul(float *a, Matrix m, float *b)
{
   int i;

   for (i=0; i<3; i++)
      b[i] = m[0][i]*a[0] + m[1][i]*a[1] + m[2][i]*a[2] + m[3][i];
}

/* writeing XYZ file */

void write_xyz(char *xyzname, int orient)
{
   FILE *xyz;
   register AtoM *ap;
   int i;
   Matrix m;
   float coord[3];
   char line[100];

   if(!actualmol){
      logprint("no molecule loaded");
      update_logs();
      return;
   }

   if((xyz = fopen(xyzname, "w")) == NULL){
      sprintf(line, "Can't open %s\n", xyzname);
      showinfobox(line);
      return;
   }

   fprintf(xyz, "%d\n", actualmol->natoms);
   fprintf(xyz, "MOLEKEL       0.0000000\n");

   if(orient == 0){
      for(ap = actualmol->firstatom, i=0; ap; ap = ap->next){
         fprintf(xyz, "%3s%15.5f%15.5f%15.5f\n", element[ap->ord].symbol,
                       ap->coord[0], ap->coord[1], ap->coord[2]);
      }
   }
   else {
      glPushMatrix();
      glLoadIdentity();
      glTranslatef(actualmol->tvec[0], actualmol->tvec[1], actualmol->tvec[2]);
      build_rotmatrix(m, actualmol->rvec);
      glMultMatrixf(&m[0][0]);

      glTranslatef(actualmol->centervec[0], actualmol->centervec[1],
                actualmol->centervec[2]);

      glGetFloatv(GL_MODELVIEW_MATRIX, &m[0][0]);
      glPopMatrix();

      for(ap = actualmol->firstatom, i=0; ap; ap = ap->next){
         matmul(ap->coord, m, coord);
         fprintf(xyz, "%3s%15.5f%15.5f%15.5f\n", element[ap->ord].symbol,
                       coord[0], coord[1], coord[2]);
      }

   }

   fclose(xyz);

}


void write_xyz_origorient(char *xyzname)
{
   write_xyz(xyzname, 0);
}

void write_xyz_currentorient(char *xyzname)
{
   write_xyz(xyzname, 1);
}

/* writing PDB file */
void write_pdb(char *pdbname, int orient)
{
   FILE *pdb;
   register AtoM *ap;
   int i;
   Matrix m;
   float coord[3];
   char line[100];

   if(!actualmol){
      logprint("no molecule loaded");
      update_logs();
      return;
   }

   if((pdb = fopen(pdbname, "w")) == NULL){
      sprintf(line, "Can't open %s\n", pdbname);
      showinfobox(line);
      return;
   }

   fprintf(pdb, "HEADER    PROTEIN\n");
   fprintf(pdb, "COMPND    SMALL MOLECULE\n");
   fprintf(pdb, "AUTHOR    GENERATED BY MOLEKEL\n");

   if(orient == 0){
      for(ap = actualmol->firstatom, i=0; ap; ap = ap->next){
         fprintf(pdb, "ATOM   %4d %2s   UNK     1    %8.3f%8.3f%8.3f  1.00  0.00\n",
                       ++i, element[ap->ord].symbol,
                       ap->coord[0], ap->coord[1], ap->coord[2]);
      }
   }
   else {
      glPushMatrix();
      glLoadIdentity();
      glTranslatef(actualmol->tvec[0], actualmol->tvec[1], actualmol->tvec[2]);
      build_rotmatrix(m, actualmol->rvec);
      glMultMatrixf(&m[0][0]);

      glTranslatef(actualmol->centervec[0], actualmol->centervec[1],
                actualmol->centervec[2]);

      glGetFloatv(GL_MODELVIEW_MATRIX, &m[0][0]);
      glPopMatrix();

      for(ap = actualmol->firstatom, i=0; ap; ap = ap->next){
         matmul(ap->coord, m, coord);
         fprintf(pdb, "ATOM   %4d %2s   unk     1    %8.3f%8.3f%8.3f  1.00  0.00\n",
                 ++i, element[ap->ord].symbol, coord[0], coord[1], coord[2]);
      }

   }

   fprintf(pdb, "END\n");

   fclose(pdb);

}


void write_pdb_origorient(char *pdbname)
{
   write_pdb(pdbname, 0);
}

void write_pdb_currentorient(char *pdbname)
{
   write_pdb(pdbname, 1);
}



/***** adapted from the MOLCAD-package *****/

#define SLD_MAGIC -4712
#define SLD_NORM 0x00000001
#define SLD_ATOM 0x00000002
#define QLEN     30
#define VERTMAX  20

void write_sld(char *sldname)
{
   Surface *sp;
   register Triangle *tp;
   Surfdot *dp;
   register int i;
   FILE *file;
   int ntri, npts, ncon, nqual;
   int head, dummy,t_flag, p;
   short sdummy;
   char name[QLEN];
   char line[100];


   if(!actualsurf) {
      showinfobox("No surface to save!");
      return;
   }
   sp = actualsurf;

   if((file = fopen(sldname, "wb")) == NULL){
      sprintf(line, "Can't open %s\n", sldname);
      showinfobox(line);
      return;
   }

   t_flag = 0;
   nqual = (sp->val != NULL);
   if (sp->second) nqual = 0;
   head = 10*sizeof(int) + nqual * sizeof(name) ;

/* 1. the header */
   dummy = SLD_MAGIC;
   fwrite(&dummy,sizeof(int),1,file);
   dummy = head;
   fwrite(&dummy,sizeof(int),1,file);
   dummy = 3 * sizeof(int);
   fwrite(&dummy,sizeof(int),1,file);
   dummy = 3 * sizeof(float);      /* x,y,z */
   t_flag |= SLD_NORM;
   dummy += 3 * sizeof(float);     /* xn,yn,zn */
   if (sp->second) {
      t_flag |= SLD_ATOM;
      dummy += sizeof(short);
   }                               /* atomic number */
   dummy += nqual * sizeof(float);  /* number of qualities */
   fwrite(&dummy,sizeof(int),1,file);
   ntri = sp->ntri;
   if(sp->second) ntri += sp->second->ntri;
   fwrite(&ntri,sizeof(int),1,file);
   npts = sp->npts;
   if(sp->second) npts += sp->second->npts;
   fwrite(&npts,sizeof(int),1,file);
   ncon = npts + ntri - 2;
   fwrite(&ncon,sizeof(int),1,file);
   fwrite(&actualmol->natoms,sizeof(int),1,file);
   fwrite(&nqual,sizeof(int),1,file);
   fwrite(&t_flag,sizeof(int),1,file);

   for(i=0;i<nqual;i++){
      strcpy(name, "qual");
      name[QLEN-1] = 0;
      fwrite(name,sizeof(char),QLEN,file);
   }

/* 2. the triangles */
   dummy = ntri;
   for (tp=sp->tri, i=0; i<sp->ntri; i++, tp++){
      fwrite(tp,sizeof(Triangle),1,file);
   }
   if(sp->second){
      Triangle t;

      for (tp=sp->second->tri, i=0; i<sp->second->ntri; i++, tp++){
         t.p1 = tp->p1 + sp->npts;
         t.p2 = tp->p2 + sp->npts;
         t.p3 = tp->p3 + sp->npts;
         fwrite(&t,sizeof(Triangle),1,file);
      }
   }

/* 3. the dots */

   sdummy = 16;
   for (i=0, dp = sp->dot; i<sp->npts; i++, dp++){
      fwrite(dp, sizeof(Surfdot), 1, file);
      if(sp->second){
         fwrite(&sdummy, sizeof(short), 1, file);
      }
      for(p=0; p<nqual; p++){
         fwrite(sp->val + i, sizeof(float), 1, file);
      }
   }
   if(sp->second){
      sdummy = 7;
      for (i=0, dp = sp->second->dot; i<sp->second->npts; i++, dp++){
         fwrite(dp, sizeof(Surfdot), 1, file);
         fwrite(&sdummy, sizeof(short), 1, file);
         for(p=0; p<nqual; p++){
            fwrite(sp->second->val + i, sizeof(float), 1, file);
         }
      }
   }


   fprintf(file,"\n\n    F I L E         \n\n");
   fprintf(file,"%8d     atoms\n", actualmol->natoms);
   fprintf(file,"%8d     dots\n", npts);
   fprintf(file,"%8d     connections\n", ncon);
   fprintf(file,"%8d     triangles\n", ntri);
   fprintf(file,"\n\nGenerated by MOLEKEL\n\n");
   fclose(file);
}



void write_ms(char *msname)
{
   Surface *sp;
   Surfdot *dp;
   register int i;
   FILE *file;
   int npts;
   float area;
   char line[100];


   if(!actualsurf) {
      showinfobox("No surface to save!");
      return;
   }
   sp = actualsurf;

   if((file = fopen(msname, "w")) == NULL){
      sprintf(line, "Can't open %s\n", msname);
      showinfobox(line);
      return;
   }

   area = orbcubesize*orbcubesize/0.64;
   npts = sp->npts; 
/* The dots */

   for (i=0, dp = sp->dot; i<npts; i++, dp++){
      fprintf(file, "XXX    1   H%9.3f%9.3f%9.3f SC%7.3f\n",
         dp->v[0], dp->v[1], dp->v[2], area);
   }

   fclose(file);

}

void write_dots_with_value(char *fn)
{
   Surface *sp;
   Surfdot *dp;
   register int i;
   FILE *file;
   int npts;
   float area, *vp;
   char line[100];


   if(!actualsurf) {
      showinfobox("No surface to save!");
      return;
   }
   if(!actualsurf->val) {
      showinfobox("No values on surface points!\nUse \"save ms");
      return;
   }

   sp = actualsurf;

   if((file = fopen(fn, "w")) == NULL){
      sprintf(line, "Can't open %s\n", fn);
      showinfobox(line);
      return;
   }

   area = orbcubesize*orbcubesize/0.64;
   npts = sp->npts; 

   for (i=0, dp = sp->dot, vp = sp->val; i<npts; i++, dp++, vp++){
      fprintf(file, "%12.6f %12.6f %12.6f %7.3f %12.6f\n",
         dp->v[0], dp->v[1], dp->v[2], area, *vp);
   }

   fclose(file);

}
